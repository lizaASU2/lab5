# Программисты предпочитают применять генераторы в тех случаях, когда нет необходимости сохранять всю последовательность
# и промежуточные значения в памяти
#Функция, которая обрабатывает большую последовательность и использует обычный return, требует от интерпретатора выделять ей много памяти.
# И если обычно такие функции не сильно влияют на производительность программы, то в проектах, содержащих последовательности с миллионами элементов,
# они потребляют очень много памяти.

# функция, возвращающая список чисел от 0 до n с помощью return
def first(n):
    m=[]
    for i in n:
        m.append(i)
    return m
#вывод списка
k=[1,2,3,4,5]
a=first(k)
print('return = ',a)

# функция, создает генератор чисел от 0 до n
def second(n):
    m = []
    for i in n:
        m.append(i)
        yield m # yield создает генератор чисел

#вывод генератора. Выводит <generator object second at 0x0296BDF0> т.к. не хранится в памяти
b=second(k)
print('yield 1= ',b)

# чтоб вернуть значения из генератора переберем их в цикле
for j in b:
    print('yield 2= ',j)

# чтоб вернуть текущее значение генератора
#print('next yield = ', next(b))