# Программисты предпочитают применять генераторы в тех случаях, когда нет необходимости сохранять всю последовательность
# и промежуточные значения в памяти
#Функция, которая обрабатывает большую последовательность и использует обычный return, требует от интерпретатора выделять ей много памяти.
# И если обычно такие функции не сильно влияют на производительность программы, то в проектах, содержащих последовательности с миллионами элементов,
# они потребляют очень много памяти.

# -----------------------часть, которую делала к чт.Просто иллистрирует работы yield-----------------------

# функция, возвращающая список чисел от 0 до n с помощью return
def first(n):
    m=[]
    for i in n:
        m.append(i)
    return m
#вывод списка
k=[1,2,3,4,5]
a=first(k)
print('return = ',a)

# функция, создает генератор чисел от 0 до n
def second(n):
    m = []
    for i in n:
        m.append(i)
        yield m # yield создает генератор чисел

#вывод генератора. Выводит <generator object second at 0x0296BDF0> т.к. не хранится в памяти
b=second(k)
print('yield 1= ',b)


# чтоб вернуть значения из генератора переберем их в цикле
for j in b:
    print('yield 2= ',j)

# чтоб вернуть текущее значение генератора
#print('next yield = ', next(b))

# ------------------------------------------------------------------------------------------

# ------------------------------норм часть--------------------------------------------------

n=[1,2,3,4,5]
#  квадрат числа
def g1(n):
    for i in n:
        yield i*i

# сумма
def g2(n):
    for i in n:
        yield i+i

# для проверки правильности работы программы
m=[]
m1=[]

# сравниваем квадраты числа с его суммой и выводим наибольшее(сравнивает каждый с каждым)
print('-----результат сравнения --------')
for x in g1(n):
    for y in g2(n):
        if (x>y):
            print('x>y= ',x)
        else:
            print('y>x= ',y)
        if y not in m:
            m.append(y)
    m1.append(x)

print('-----исходные списки--------')
print('квадрат=', m1)
print('сумма =', m)

# тоже самое, но читаем из файла

# файл 1
def r1(file):
    with open(file) as f:
        for line in f:
            lst = line.split()
            yield lst

s=[]
s1=[]

# сравниваем числа из двух файлов и выводим наибольшее
print('-----результат сравнения --------')
for x1 in r1('f1.txt'):
    for y1 in r1('f2.txt'):
        if (len(x1)>=len(y1)):
             print('из f1= ',x1)
        else:
            print('из f2= ',y1)
        if y1 not in s:
             s.append(y1)
    s1.append(x1)


print('-----исходные списки--------')
print('мсходный файл 1=', s1)
print('исходный файл 2 =', s)